from . import nodes
from . import util

import subprocess
import shlex

class GccCompiler(nodes.Builder):
    def __init__(self, context):
        super().__init__(context)
        self.executable = "gcc"
        self.cflags = []

    def build(self, input_paths, output_paths):
        """ Build input_paths is a list of pathlib.Path objects that should be
        compiled into list of patlib.Path objects output_paths. """

        with self.context.tempfile() as depfile:
            commandline = [self.executable]
            commandline.extend(self.cflags)
            commandline = [self.expand_variables(x) for x in commandline]

            commandline.extend(["-c",
                                "-MD",
                                "-MF", str(depfile),
                                "-o", str(output_paths[0]),
                                str(input_paths[0])])
            self.context.run_command(commandline)

            with depfile.open("r") as fp:
                return self._parse_dependencies(fp.read())

    def get_output_count(self, input_count):
        """ Return how many files will be generated by this build step.
        This is also a good place to check for correct number of inputs. """

        if input_count != 1:
            raise RuntimeError("There must be exactly one input file")
        return 1

    def get_hash(self):
        return util.sha1_iterable([self.executable], self.cflags)

    def create_associated_linker(self):
        """ Returns a linker that uses the same gcc executable as this compiler
        and initially passes the same cflags. """
        linker = GccLinker(self.context)
        linker.executable = self.executable
        linker.cflags = self.cflags[:]

        for name, dep in self.named_dependencies.items():
            assert dep not in linker.dependencies
            linker.add_dependency(dep, name)

        return linker

    @staticmethod
    def _parse_dependencies(dependencies):
        split = shlex.split(dependencies)

        if not len(split):
            return []

        if not split[0].endswith(":"):
            raise Exception("Unexpected dependencies string.")

        return sorted(set(x for x in split[1:] if x.strip()))

class GccLinker(nodes.Builder):
    def __init__(self, context):
        super().__init__(context)
        self.executable = "gcc"
        self.cflags = []

    def build(self, input_paths, output_paths):
        """ Build input_paths is a list of pathlib.Path objects that should be
        compiled into list of patlib.Path objects output_paths. """

        with self.context.tempfile("dep") as depfile:
            commandline = [self.executable]
            commandline.extend(self.cflags)
            commandline = [self.expand_variables(x) for x in commandline]

            commandline.extend(["-Wl,--trace",
                                "-o", str(output_paths[0])])
            commandline.extend(str(f) for f in input_paths)
            self.context.run_command(commandline)

            #TODO: return dependencies;

    def get_output_count(self, input_count):
        """ Return how many files will be generated by this build step.
        This is also a good place to check for correct number of inputs. """

        if input_count <= 1:
            raise RuntimeError("There must be at least one input file")
        return 1

    def get_hash(self):
        return self.hash_helper([self.executable], self.cflags)
